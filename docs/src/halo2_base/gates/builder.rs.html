<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `halo2-base/src/gates/builder.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>builder.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../../halo2_base/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
</pre><pre class="rust"><code><span class="kw">use super</span>::{
    flex_gate::{FlexGateConfig, GateStrategy, MAX_PHASE},
    range::{RangeConfig, RangeStrategy},
};
<span class="kw">use crate</span>::{
    halo2_proofs::{
        circuit::{<span class="self">self</span>, Layouter, Region, SimpleFloorPlanner, Value},
        plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Instance, Selector},
    },
    utils::ScalarField,
    AssignedValue, Context, SKIP_FIRST_PASS,
};
<span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="kw">use </span>std::{
    cell::RefCell,
    collections::{HashMap, HashSet},
    env::{set_var, var},
};

<span class="kw">mod </span>parallelize;
<span class="kw">pub use </span>parallelize::<span class="kw-2">*</span>;

<span class="doccomment">/// Vector of thread advice column break points
</span><span class="kw">pub type </span>ThreadBreakPoints = Vec&lt;usize&gt;;
<span class="doccomment">/// Vector of vectors tracking the thread break points across different halo2 phases
</span><span class="kw">pub type </span>MultiPhaseThreadBreakPoints = Vec&lt;ThreadBreakPoints&gt;;

<span class="doccomment">/// Stores the cell values loaded during the Keygen phase of a halo2 proof and breakpoints for multi-threading
</span><span class="attribute">#[derive(Clone, Debug, Default)]
</span><span class="kw">pub struct </span>KeygenAssignments&lt;F: ScalarField&gt; {
    <span class="doccomment">/// Advice assignments
    </span><span class="kw">pub </span>assigned_advices: HashMap&lt;(usize, usize), (circuit::Cell, usize)&gt;, <span class="comment">// (key = ContextCell, value = (circuit::Cell, row offset))
    </span><span class="doccomment">/// Constant assignments in Fixes Assignments
    </span><span class="kw">pub </span>assigned_constants: HashMap&lt;F, circuit::Cell&gt;, <span class="comment">// (key = constant, value = circuit::Cell)
    </span><span class="doccomment">/// Advice column break points for threads in each phase.
    </span><span class="kw">pub </span>break_points: MultiPhaseThreadBreakPoints,
}

<span class="doccomment">/// Builds the process for gate threading
</span><span class="attribute">#[derive(Clone, Debug, Default)]
</span><span class="kw">pub struct </span>GateThreadBuilder&lt;F: ScalarField&gt; {
    <span class="doccomment">/// Threads for each challenge phase
    </span><span class="kw">pub </span>threads: [Vec&lt;Context&lt;F&gt;&gt;; MAX_PHASE],
    <span class="doccomment">/// Max number of threads
    </span>thread_count: usize,
    <span class="doccomment">/// Flag for witness generation. If true, the gate thread builder is used for witness generation only.
    </span><span class="kw">pub </span>witness_gen_only: bool,
    <span class="doccomment">/// The `unknown` flag is used during key generation. If true, during key generation witness [Value]s are replaced with Value::unknown() for safety.
    </span>use_unknown: bool,
}

<span class="kw">impl</span>&lt;F: ScalarField&gt; GateThreadBuilder&lt;F&gt; {
    <span class="doccomment">/// Creates a new [GateThreadBuilder] and spawns a main thread in phase 0.
    /// * `witness_gen_only`: If true, the [GateThreadBuilder] is used for witness generation only.
    ///     * If true, the gate thread builder only does witness assignments and does not store constraint information -- this should only be used for the real prover.
    ///     * If false, the gate thread builder is used for keygen and mock prover (it can also be used for real prover) and the builder stores circuit information (e.g. copy constraints, fixed columns, enabled selectors).
    ///         * These values are fixed for the circuit at key generation time, and they do not need to be re-computed by the prover in the actual proving phase.
    </span><span class="kw">pub fn </span>new(witness_gen_only: bool) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>threads = [(); MAX_PHASE].map(|<span class="kw">_</span>| <span class="macro">vec!</span>[]);
        <span class="comment">// start with a main thread in phase 0
        </span>threads[<span class="number">0</span>].push(Context::new(witness_gen_only, <span class="number">0</span>));
        <span class="self">Self </span>{ threads, thread_count: <span class="number">1</span>, witness_gen_only, use_unknown: <span class="bool-val">false </span>}
    }

    <span class="doccomment">/// Creates a new [GateThreadBuilder] with `witness_gen_only` set to false.
    ///
    /// Performs the witness assignment computations and then checks using normal programming logic whether the gate constraints are all satisfied.
    </span><span class="kw">pub fn </span>mock() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::new(<span class="bool-val">false</span>)
    }

    <span class="doccomment">/// Creates a new [GateThreadBuilder] with `witness_gen_only` set to false.
    ///
    /// Performs the witness assignment computations and generates prover and verifier keys.
    </span><span class="kw">pub fn </span>keygen() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::new(<span class="bool-val">false</span>)
    }

    <span class="doccomment">/// Creates a new [GateThreadBuilder] with `witness_gen_only` set to true.
    ///
    /// Performs the witness assignment computations and then runs the proving system.
    </span><span class="kw">pub fn </span>prover() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::new(<span class="bool-val">true</span>)
    }

    <span class="doccomment">/// Creates a new [GateThreadBuilder] with `use_unknown` flag set.
    /// * `use_unknown`: If true, during key generation witness [Value]s are replaced with Value::unknown() for safety.
    </span><span class="kw">pub fn </span>unknown(<span class="self">self</span>, use_unknown: bool) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ use_unknown, ..<span class="self">self </span>}
    }

    <span class="doccomment">/// Returns a mutable reference to the [Context] of a gate thread. Spawns a new thread for the given phase, if none exists.
    /// * `phase`: The challenge phase (as an index) of the gate thread.
    </span><span class="kw">pub fn </span>main(<span class="kw-2">&amp;mut </span><span class="self">self</span>, phase: usize) -&gt; <span class="kw-2">&amp;mut </span>Context&lt;F&gt; {
        <span class="kw">if </span><span class="self">self</span>.threads[phase].is_empty() {
            <span class="self">self</span>.new_thread(phase)
        } <span class="kw">else </span>{
            <span class="self">self</span>.threads[phase].last_mut().unwrap()
        }
    }

    <span class="doccomment">/// Returns the `witness_gen_only` flag.
    </span><span class="kw">pub fn </span>witness_gen_only(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.witness_gen_only
    }

    <span class="doccomment">/// Returns the `use_unknown` flag.
    </span><span class="kw">pub fn </span>use_unknown(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.use_unknown
    }

    <span class="doccomment">/// Returns the current number of threads in the [GateThreadBuilder].
    </span><span class="kw">pub fn </span>thread_count(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.thread_count
    }

    <span class="doccomment">/// Creates a new thread id by incrementing the `thread count`
    </span><span class="kw">pub fn </span>get_new_thread_id(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; usize {
        <span class="kw">let </span>thread_id = <span class="self">self</span>.thread_count;
        <span class="self">self</span>.thread_count += <span class="number">1</span>;
        thread_id
    }

    <span class="doccomment">/// Spawns a new thread for a new given `phase`. Returns a mutable reference to the [Context] of the new thread.
    /// * `phase`: The phase (index) of the gate thread.
    </span><span class="kw">pub fn </span>new_thread(<span class="kw-2">&amp;mut </span><span class="self">self</span>, phase: usize) -&gt; <span class="kw-2">&amp;mut </span>Context&lt;F&gt; {
        <span class="kw">let </span>thread_id = <span class="self">self</span>.thread_count;
        <span class="self">self</span>.thread_count += <span class="number">1</span>;
        <span class="self">self</span>.threads[phase].push(Context::new(<span class="self">self</span>.witness_gen_only, thread_id));
        <span class="self">self</span>.threads[phase].last_mut().unwrap()
    }

    <span class="doccomment">/// Auto-calculates configuration parameters for the circuit
    ///
    /// * `k`: The number of in the circuit (i.e. number of rows = 2&lt;sup&gt;k&lt;/sup&gt;)
    /// * `minimum_rows`: The minimum number of rows in the circuit that cannot be used for witness assignments and contain random `blinding factors` to ensure zk property, defaults to 0.
    </span><span class="kw">pub fn </span>config(<span class="kw-2">&amp;</span><span class="self">self</span>, k: usize, minimum_rows: <span class="prelude-ty">Option</span>&lt;usize&gt;) -&gt; FlexGateConfigParams {
        <span class="kw">let </span>max_rows = (<span class="number">1 </span>&lt;&lt; k) - minimum_rows.unwrap_or(<span class="number">0</span>);
        <span class="kw">let </span>total_advice_per_phase = <span class="self">self
            </span>.threads
            .iter()
            .map(|threads| threads.iter().map(|ctx| ctx.advice.len()).sum::&lt;usize&gt;())
            .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
        <span class="comment">// we do a rough estimate by taking ceil(advice_cells_per_phase / 2^k )
        // if this is too small, manual configuration will be needed
        </span><span class="kw">let </span>num_advice_per_phase = total_advice_per_phase
            .iter()
            .map(|count| (count + max_rows - <span class="number">1</span>) / max_rows)
            .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

        <span class="kw">let </span>total_lookup_advice_per_phase = <span class="self">self
            </span>.threads
            .iter()
            .map(|threads| threads.iter().map(|ctx| ctx.cells_to_lookup.len()).sum::&lt;usize&gt;())
            .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
        <span class="kw">let </span>num_lookup_advice_per_phase = total_lookup_advice_per_phase
            .iter()
            .map(|count| (count + max_rows - <span class="number">1</span>) / max_rows)
            .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

        <span class="kw">let </span>total_fixed: usize = HashSet::&lt;F&gt;::from_iter(<span class="self">self</span>.threads.iter().flat_map(|threads| {
            threads.iter().flat_map(|ctx| ctx.constant_equality_constraints.iter().map(|(c, <span class="kw">_</span>)| <span class="kw-2">*</span>c))
        }))
        .len();
        <span class="kw">let </span>num_fixed = (total_fixed + (<span class="number">1 </span>&lt;&lt; k) - <span class="number">1</span>) &gt;&gt; k;

        <span class="kw">let </span>params = FlexGateConfigParams {
            strategy: GateStrategy::Vertical,
            num_advice_per_phase,
            num_lookup_advice_per_phase,
            num_fixed,
            k,
        };
        <span class="attribute">#[cfg(feature = <span class="string">&quot;display&quot;</span>)]
        </span>{
            <span class="kw">for </span>phase <span class="kw">in </span><span class="number">0</span>..MAX_PHASE {
                <span class="kw">if </span>total_advice_per_phase[phase] != <span class="number">0 </span>|| total_lookup_advice_per_phase[phase] != <span class="number">0 </span>{
                    <span class="macro">println!</span>(
                        <span class="string">&quot;Gate Chip | Phase {}: {} advice cells , {} lookup advice cells&quot;</span>,
                        phase, total_advice_per_phase[phase], total_lookup_advice_per_phase[phase],
                    );
                }
            }
            <span class="macro">println!</span>(<span class="string">&quot;Total {total_fixed} fixed cells&quot;</span>);
            <span class="macro">log::info!</span>(<span class="string">&quot;Auto-calculated config params:\n {params:#?}&quot;</span>);
        }
        set_var(<span class="string">&quot;FLEX_GATE_CONFIG_PARAMS&quot;</span>, serde_json::to_string(<span class="kw-2">&amp;</span>params).unwrap());
        params
    }

    <span class="doccomment">/// Assigns all advice and fixed cells, turns on selectors, and imposes equality constraints.
    ///
    /// Returns the assigned advices, and constants in the form of [KeygenAssignments].
    ///
    /// Assumes selector and advice columns are already allocated and of the same length.
    ///
    /// Note: `assign_all()` **should** be called during keygen or if using mock prover. It also works for the real prover, but there it is more optimal to use [`assign_threads_in`] instead.
    /// * `config`: The [FlexGateConfig] of the circuit.
    /// * `lookup_advice`: The lookup advice columns.
    /// * `q_lookup`: The lookup advice selectors.
    /// * `region`: The [Region] of the circuit.
    /// * `assigned_advices`: The assigned advice cells.
    /// * `assigned_constants`: The assigned fixed cells.
    /// * `break_points`: The break points of the circuit.
    </span><span class="kw">pub fn </span>assign_all(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        config: <span class="kw-2">&amp;</span>FlexGateConfig&lt;F&gt;,
        lookup_advice: <span class="kw-2">&amp;</span>[Vec&lt;Column&lt;Advice&gt;&gt;],
        q_lookup: <span class="kw-2">&amp;</span>[<span class="prelude-ty">Option</span>&lt;Selector&gt;],
        region: <span class="kw-2">&amp;mut </span>Region&lt;F&gt;,
        KeygenAssignments {
            <span class="kw-2">mut </span>assigned_advices,
            <span class="kw-2">mut </span>assigned_constants,
            <span class="kw-2">mut </span>break_points
        }: KeygenAssignments&lt;F&gt;,
    ) -&gt; KeygenAssignments&lt;F&gt; {
        <span class="kw">let </span>use_unknown = <span class="self">self</span>.use_unknown;
        <span class="kw">let </span>max_rows = config.max_rows;
        <span class="kw">let </span><span class="kw-2">mut </span>fixed_col = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>fixed_offset = <span class="number">0</span>;
        <span class="kw">for </span>(phase, threads) <span class="kw">in </span><span class="self">self</span>.threads.iter().enumerate() {
            <span class="kw">let </span><span class="kw-2">mut </span>break_point = <span class="macro">vec!</span>[];
            <span class="kw">let </span><span class="kw-2">mut </span>gate_index = <span class="number">0</span>;
            <span class="kw">let </span><span class="kw-2">mut </span>row_offset = <span class="number">0</span>;
            <span class="kw">for </span>ctx <span class="kw">in </span>threads {
                <span class="kw">let </span><span class="kw-2">mut </span>basic_gate = config.basic_gates[phase]
                        .get(gate_index)
                        .unwrap_or_else(|| <span class="macro">panic!</span>(<span class="string">&quot;NOT ENOUGH ADVICE COLUMNS IN PHASE {phase}. Perhaps blinding factors were not taken into account. The max non-poisoned rows is {max_rows}&quot;</span>));
                <span class="macro">assert_eq!</span>(ctx.selector.len(), ctx.advice.len());

                <span class="kw">for </span>(i, (advice, <span class="kw-2">&amp;</span>q)) <span class="kw">in </span>ctx.advice.iter().zip(ctx.selector.iter()).enumerate() {
                    <span class="kw">let </span>column = basic_gate.value;
                    <span class="kw">let </span>value = <span class="kw">if </span>use_unknown { Value::unknown() } <span class="kw">else </span>{ Value::known(advice) };
                    <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                    </span><span class="kw">let </span>cell = <span class="kw-2">*</span>region.assign_advice(column, row_offset, value).cell();
                    <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                    </span><span class="kw">let </span>cell = region
                        .assign_advice(|| <span class="string">&quot;&quot;</span>, column, row_offset, || value.map(|v| <span class="kw-2">*</span>v))
                        .unwrap()
                        .cell();
                    assigned_advices.insert((ctx.context_id, i), (cell, row_offset));

                    <span class="comment">// If selector enabled and row_offset is valid add break point to Keygen Assignments, account for break point overlap, and enforce equality constraint for gate outputs.
                    </span><span class="kw">if </span>(q &amp;&amp; row_offset + <span class="number">4 </span>&gt; max_rows) || row_offset &gt;= max_rows - <span class="number">1 </span>{
                        break_point.push(row_offset);
                        row_offset = <span class="number">0</span>;
                        gate_index += <span class="number">1</span>;

                        <span class="comment">// when there is a break point, because we may have two gates that overlap at the current cell, we must copy the current cell to the next column for safety
                        </span>basic_gate = config.basic_gates[phase]
                        .get(gate_index)
                        .unwrap_or_else(|| <span class="macro">panic!</span>(<span class="string">&quot;NOT ENOUGH ADVICE COLUMNS IN PHASE {phase}. Perhaps blinding factors were not taken into account. The max non-poisoned rows is {max_rows}&quot;</span>));
                        <span class="kw">let </span>column = basic_gate.value;

                        <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                        </span>{
                            <span class="kw">let </span>ncell = region.assign_advice(column, row_offset, value);
                            region.constrain_equal(ncell.cell(), <span class="kw-2">&amp;</span>cell);
                        }
                        <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                        </span>{
                            <span class="kw">let </span>ncell = region
                                .assign_advice(|| <span class="string">&quot;&quot;</span>, column, row_offset, || value.map(|v| <span class="kw-2">*</span>v))
                                .unwrap()
                                .cell();
                            region.constrain_equal(ncell, cell).unwrap();
                        }
                    }

                    <span class="kw">if </span>q {
                        basic_gate
                            .q_enable
                            .enable(region, row_offset)
                            .expect(<span class="string">&quot;enable selector should not fail&quot;</span>);
                    }

                    row_offset += <span class="number">1</span>;
                }
                <span class="comment">// Assign fixed cells
                </span><span class="kw">for </span>(c, <span class="kw">_</span>) <span class="kw">in </span>ctx.constant_equality_constraints.iter() {
                    <span class="kw">if </span>assigned_constants.get(c).is_none() {
                        <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                        </span><span class="kw">let </span>cell =
                            region.assign_fixed(config.constants[fixed_col], fixed_offset, c);
                        <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                        </span><span class="kw">let </span>cell = region
                            .assign_fixed(
                                || <span class="string">&quot;&quot;</span>,
                                config.constants[fixed_col],
                                fixed_offset,
                                || Value::known(<span class="kw-2">*</span>c),
                            )
                            .unwrap()
                            .cell();
                        assigned_constants.insert(<span class="kw-2">*</span>c, cell);
                        fixed_col += <span class="number">1</span>;
                        <span class="kw">if </span>fixed_col &gt;= config.constants.len() {
                            fixed_col = <span class="number">0</span>;
                            fixed_offset += <span class="number">1</span>;
                        }
                    }
                }
            }
            break_points.push(break_point);
        }
        <span class="comment">// we constrain equality constraints in a separate loop in case context `i` contains references to context `j` for `j &gt; i`
        </span><span class="kw">for </span>(phase, threads) <span class="kw">in </span><span class="self">self</span>.threads.iter().enumerate() {
            <span class="kw">let </span><span class="kw-2">mut </span>lookup_offset = <span class="number">0</span>;
            <span class="kw">let </span><span class="kw-2">mut </span>lookup_col = <span class="number">0</span>;
            <span class="kw">for </span>ctx <span class="kw">in </span>threads {
                <span class="kw">for </span>(left, right) <span class="kw">in </span><span class="kw-2">&amp;</span>ctx.advice_equality_constraints {
                    <span class="kw">let </span>(left, <span class="kw">_</span>) = assigned_advices[<span class="kw-2">&amp;</span>(left.context_id, left.offset)];
                    <span class="kw">let </span>(right, <span class="kw">_</span>) = assigned_advices[<span class="kw-2">&amp;</span>(right.context_id, right.offset)];
                    <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                    </span>region.constrain_equal(<span class="kw-2">&amp;</span>left, <span class="kw-2">&amp;</span>right);
                    <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                    </span>region.constrain_equal(left, right).unwrap();
                }
                <span class="kw">for </span>(left, right) <span class="kw">in </span><span class="kw-2">&amp;</span>ctx.constant_equality_constraints {
                    <span class="kw">let </span>left = assigned_constants[left];
                    <span class="kw">let </span>(right, <span class="kw">_</span>) = assigned_advices[<span class="kw-2">&amp;</span>(right.context_id, right.offset)];
                    <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                    </span>region.constrain_equal(<span class="kw-2">&amp;</span>left, <span class="kw-2">&amp;</span>right);
                    <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                    </span>region.constrain_equal(left, right).unwrap();
                }

                <span class="kw">for </span>advice <span class="kw">in </span><span class="kw-2">&amp;</span>ctx.cells_to_lookup {
                    <span class="comment">// if q_lookup is Some, that means there should be a single advice column and it has lookup enabled
                    </span><span class="kw">let </span>cell = advice.cell.unwrap();
                    <span class="kw">let </span>(acell, row_offset) = assigned_advices[<span class="kw-2">&amp;</span>(cell.context_id, cell.offset)];
                    <span class="kw">if let </span><span class="prelude-val">Some</span>(q_lookup) = q_lookup[phase] {
                        <span class="macro">assert_eq!</span>(config.basic_gates[phase].len(), <span class="number">1</span>);
                        q_lookup.enable(region, row_offset).unwrap();
                        <span class="kw">continue</span>;
                    }
                    <span class="comment">// otherwise, we copy the advice value to the special lookup_advice columns
                    </span><span class="kw">if </span>lookup_offset &gt;= max_rows {
                        lookup_offset = <span class="number">0</span>;
                        lookup_col += <span class="number">1</span>;
                    }
                    <span class="kw">let </span>value = advice.value;
                    <span class="kw">let </span>value = <span class="kw">if </span>use_unknown { Value::unknown() } <span class="kw">else </span>{ Value::known(value) };
                    <span class="kw">let </span>column = lookup_advice[phase][lookup_col];

                    <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                    </span>{
                        <span class="kw">let </span>bcell = region.assign_advice(column, lookup_offset, value);
                        region.constrain_equal(<span class="kw-2">&amp;</span>acell, bcell.cell());
                    }
                    <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                    </span>{
                        <span class="kw">let </span>bcell = region
                            .assign_advice(|| <span class="string">&quot;&quot;</span>, column, lookup_offset, || value)
                            .expect(<span class="string">&quot;assign_advice should not fail&quot;</span>)
                            .cell();
                        region.constrain_equal(acell, bcell).unwrap();
                    }
                    lookup_offset += <span class="number">1</span>;
                }
            }
        }
        KeygenAssignments { assigned_advices, assigned_constants, break_points }
    }
}

<span class="doccomment">/// Assigns threads to regions of advice column.
///
/// Uses preprocessed `break_points` to assign where to divide the advice column into a new column for each thread.
///
/// Performs only witness generation, so should only be evoked during proving not keygen.
///
/// Assumes that the advice columns are already assigned.
/// * `phase` - the phase of the circuit
/// * `threads` - [Vec] threads to assign
/// * `config` - immutable reference to the configuration of the circuit
/// * `lookup_advice` - Slice of lookup advice columns
/// * `region` - mutable reference to the region to assign threads to
/// * `break_points` - the preprocessed break points for the threads
</span><span class="kw">pub fn </span>assign_threads_in&lt;F: ScalarField&gt;(
    phase: usize,
    threads: Vec&lt;Context&lt;F&gt;&gt;,
    config: <span class="kw-2">&amp;</span>FlexGateConfig&lt;F&gt;,
    lookup_advice: <span class="kw-2">&amp;</span>[Column&lt;Advice&gt;],
    region: <span class="kw-2">&amp;mut </span>Region&lt;F&gt;,
    break_points: ThreadBreakPoints,
) {
    <span class="kw">if </span>config.basic_gates[phase].is_empty() {
        <span class="macro">assert!</span>(threads.is_empty(), <span class="string">&quot;Trying to assign threads in a phase with no columns&quot;</span>);
        <span class="kw">return</span>;
    }

    <span class="kw">let </span><span class="kw-2">mut </span>break_points = break_points.into_iter();
    <span class="kw">let </span><span class="kw-2">mut </span>break_point = break_points.next();

    <span class="kw">let </span><span class="kw-2">mut </span>gate_index = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>column = config.basic_gates[phase][gate_index].value;
    <span class="kw">let </span><span class="kw-2">mut </span>row_offset = <span class="number">0</span>;

    <span class="kw">let </span><span class="kw-2">mut </span>lookup_offset = <span class="number">0</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>lookup_advice = lookup_advice.iter();
    <span class="kw">let </span><span class="kw-2">mut </span>lookup_column = lookup_advice.next();
    <span class="kw">for </span>ctx <span class="kw">in </span>threads {
        <span class="comment">// if lookup_column is [None], that means there should be a single advice column and it has lookup enabled, so we don&#39;t need to copy to special lookup advice columns
        </span><span class="kw">if </span>lookup_column.is_some() {
            <span class="kw">for </span>advice <span class="kw">in </span>ctx.cells_to_lookup {
                <span class="kw">if </span>lookup_offset &gt;= config.max_rows {
                    lookup_offset = <span class="number">0</span>;
                    lookup_column = lookup_advice.next();
                }
                <span class="comment">// Assign the lookup advice values to the lookup_column
                </span><span class="kw">let </span>value = advice.value;
                <span class="kw">let </span>lookup_column = <span class="kw-2">*</span>lookup_column.unwrap();
                <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                </span>region.assign_advice(lookup_column, lookup_offset, Value::known(value));
                <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                </span>region
                    .assign_advice(|| <span class="string">&quot;&quot;</span>, lookup_column, lookup_offset, || Value::known(value))
                    .unwrap();

                lookup_offset += <span class="number">1</span>;
            }
        }
        <span class="comment">// Assign advice values to the advice columns in each [Context]
        </span><span class="kw">for </span>advice <span class="kw">in </span>ctx.advice {
            <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
            </span>region.assign_advice(column, row_offset, Value::known(advice));
            <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
            </span>region.assign_advice(|| <span class="string">&quot;&quot;</span>, column, row_offset, || Value::known(advice)).unwrap();

            <span class="kw">if </span>break_point == <span class="prelude-val">Some</span>(row_offset) {
                break_point = break_points.next();
                row_offset = <span class="number">0</span>;
                gate_index += <span class="number">1</span>;
                column = config.basic_gates[phase][gate_index].value;

                <span class="attribute">#[cfg(feature = <span class="string">&quot;halo2-axiom&quot;</span>)]
                </span>region.assign_advice(column, row_offset, Value::known(advice));
                <span class="attribute">#[cfg(not(feature = <span class="string">&quot;halo2-axiom&quot;</span>))]
                </span>region.assign_advice(|| <span class="string">&quot;&quot;</span>, column, row_offset, || Value::known(advice)).unwrap();
            }

            row_offset += <span class="number">1</span>;
        }
    }
}

<span class="doccomment">/// A Config struct defining the parameters for a FlexGate circuit.
</span><span class="attribute">#[derive(Clone, Debug, Serialize, Deserialize)]
</span><span class="kw">pub struct </span>FlexGateConfigParams {
    <span class="doccomment">/// The gate strategy used for the advice column of the circuit and applied at every row.
    </span><span class="kw">pub </span>strategy: GateStrategy,
    <span class="doccomment">/// Security parameter `k` used for the keygen.
    </span><span class="kw">pub </span>k: usize,
    <span class="doccomment">/// The number of advice columns per phase
    </span><span class="kw">pub </span>num_advice_per_phase: Vec&lt;usize&gt;,
    <span class="doccomment">/// The number of advice columns that do not have lookup enabled per phase
    </span><span class="kw">pub </span>num_lookup_advice_per_phase: Vec&lt;usize&gt;,
    <span class="doccomment">/// The number of fixed columns per phase
    </span><span class="kw">pub </span>num_fixed: usize,
}

<span class="doccomment">/// A wrapper struct to auto-build a circuit from a `GateThreadBuilder`.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>GateCircuitBuilder&lt;F: ScalarField&gt; {
    <span class="doccomment">/// The Thread Builder for the circuit
    </span><span class="kw">pub </span>builder: RefCell&lt;GateThreadBuilder&lt;F&gt;&gt;, <span class="comment">// `RefCell` is just to trick circuit `synthesize` to take ownership of the inner builder
    </span><span class="doccomment">/// Break points for threads within the circuit
    </span><span class="kw">pub </span>break_points: RefCell&lt;MultiPhaseThreadBreakPoints&gt;, <span class="comment">// `RefCell` allows the circuit to record break points in a keygen call of `synthesize` for use in later witness gen
</span>}

<span class="kw">impl</span>&lt;F: ScalarField&gt; GateCircuitBuilder&lt;F&gt; {
    <span class="doccomment">/// Creates a new [GateCircuitBuilder] with `use_unknown` of [GateThreadBuilder] set to true.
    </span><span class="kw">pub fn </span>keygen(builder: GateThreadBuilder&lt;F&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ builder: RefCell::new(builder.unknown(<span class="bool-val">true</span>)), break_points: RefCell::new(<span class="macro">vec!</span>[]) }
    }

    <span class="doccomment">/// Creates a new [GateCircuitBuilder] with `use_unknown` of [GateThreadBuilder] set to false.
    </span><span class="kw">pub fn </span>mock(builder: GateThreadBuilder&lt;F&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ builder: RefCell::new(builder.unknown(<span class="bool-val">false</span>)), break_points: RefCell::new(<span class="macro">vec!</span>[]) }
    }

    <span class="doccomment">/// Creates a new [GateCircuitBuilder].
    </span><span class="kw">pub fn </span>prover(
        builder: GateThreadBuilder&lt;F&gt;,
        break_points: MultiPhaseThreadBreakPoints,
    ) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ builder: RefCell::new(builder), break_points: RefCell::new(break_points) }
    }

    <span class="doccomment">/// Synthesizes from the [GateCircuitBuilder] by populating the advice column and assigning new threads if witness generation is performed.
    </span><span class="kw">pub fn </span>sub_synthesize(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        gate: <span class="kw-2">&amp;</span>FlexGateConfig&lt;F&gt;,
        lookup_advice: <span class="kw-2">&amp;</span>[Vec&lt;Column&lt;Advice&gt;&gt;],
        q_lookup: <span class="kw-2">&amp;</span>[<span class="prelude-ty">Option</span>&lt;Selector&gt;],
        layouter: <span class="kw-2">&amp;mut </span><span class="kw">impl </span>Layouter&lt;F&gt;,
    ) -&gt; HashMap&lt;(usize, usize), (circuit::Cell, usize)&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>first_pass = SKIP_FIRST_PASS;
        <span class="kw">let </span><span class="kw-2">mut </span>assigned_advices = HashMap::new();
        layouter
            .assign_region(
                || <span class="string">&quot;GateCircuitBuilder generated circuit&quot;</span>,
                |<span class="kw-2">mut </span>region| {
                    <span class="kw">if </span>first_pass {
                        first_pass = <span class="bool-val">false</span>;
                        <span class="kw">return </span><span class="prelude-val">Ok</span>(());
                    }
                    <span class="comment">// only support FirstPhase in this Builder because getting challenge value requires more specialized witness generation during synthesize
                    // If we are not performing witness generation only, we can skip the first pass and assign threads directly
                    </span><span class="kw">if </span>!<span class="self">self</span>.builder.borrow().witness_gen_only {
                        <span class="comment">// clone the builder so we can re-use the circuit for both vk and pk gen
                        </span><span class="kw">let </span>builder = <span class="self">self</span>.builder.borrow().clone();
                        <span class="kw">for </span>threads <span class="kw">in </span>builder.threads.iter().skip(<span class="number">1</span>) {
                            <span class="macro">assert!</span>(
                                threads.is_empty(),
                                <span class="string">&quot;GateCircuitBuilder only supports FirstPhase for now&quot;
                            </span>);
                        }
                        <span class="kw">let </span>assignments = builder.assign_all(
                            gate,
                            lookup_advice,
                            q_lookup,
                            <span class="kw-2">&amp;mut </span>region,
                            Default::default(),
                        );
                        <span class="kw-2">*</span><span class="self">self</span>.break_points.borrow_mut() = assignments.break_points;
                        assigned_advices = assignments.assigned_advices;
                    } <span class="kw">else </span>{
                        <span class="comment">// If we are only generating witness, we can skip the first pass and assign threads directly
                        </span><span class="kw">let </span>builder = <span class="self">self</span>.builder.take();
                        <span class="kw">let </span>break_points = <span class="self">self</span>.break_points.take();
                        <span class="kw">for </span>(phase, (threads, break_points)) <span class="kw">in </span>builder
                            .threads
                            .into_iter()
                            .zip(break_points.into_iter())
                            .enumerate()
                            .take(<span class="number">1</span>)
                        {
                            assign_threads_in(
                                phase,
                                threads,
                                gate,
                                lookup_advice.get(phase).unwrap_or(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[]),
                                <span class="kw-2">&amp;mut </span>region,
                                break_points,
                            );
                        }
                    }
                    <span class="prelude-val">Ok</span>(())
                },
            )
            .unwrap();
        assigned_advices
    }
}

<span class="kw">impl</span>&lt;F: ScalarField&gt; Circuit&lt;F&gt; <span class="kw">for </span>GateCircuitBuilder&lt;F&gt; {
    <span class="kw">type </span>Config = FlexGateConfig&lt;F&gt;;
    <span class="kw">type </span>FloorPlanner = SimpleFloorPlanner;

    <span class="doccomment">/// Creates a new instance of the circuit without withnesses filled in.
    </span><span class="kw">fn </span>without_witnesses(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self </span>{
        <span class="macro">unimplemented!</span>()
    }

    <span class="doccomment">/// Configures a new circuit using the the parameters specified [Config].
    </span><span class="kw">fn </span>configure(meta: <span class="kw-2">&amp;mut </span>ConstraintSystem&lt;F&gt;) -&gt; FlexGateConfig&lt;F&gt; {
        <span class="kw">let </span>FlexGateConfigParams {
            strategy,
            num_advice_per_phase,
            num_lookup_advice_per_phase: <span class="kw">_</span>,
            num_fixed,
            k,
        } = serde_json::from_str(<span class="kw-2">&amp;</span>var(<span class="string">&quot;FLEX_GATE_CONFIG_PARAMS&quot;</span>).unwrap()).unwrap();
        FlexGateConfig::configure(meta, strategy, <span class="kw-2">&amp;</span>num_advice_per_phase, num_fixed, k)
    }

    <span class="doccomment">/// Performs the actual computation on the circuit (e.g., witness generation), filling in all the advice values for a particular proof.
    </span><span class="kw">fn </span>synthesize(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        config: <span class="self">Self</span>::Config,
        <span class="kw-2">mut </span>layouter: <span class="kw">impl </span>Layouter&lt;F&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
        <span class="self">self</span>.sub_synthesize(<span class="kw-2">&amp;</span>config, <span class="kw-2">&amp;</span>[], <span class="kw-2">&amp;</span>[], <span class="kw-2">&amp;mut </span>layouter);
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="doccomment">/// A wrapper struct to auto-build a circuit from a `GateThreadBuilder`.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>RangeCircuitBuilder&lt;F: ScalarField&gt;(<span class="kw">pub </span>GateCircuitBuilder&lt;F&gt;);

<span class="kw">impl</span>&lt;F: ScalarField&gt; RangeCircuitBuilder&lt;F&gt; {
    <span class="doccomment">/// Creates an instance of the [RangeCircuitBuilder] and executes in keygen mode.
    </span><span class="kw">pub fn </span>keygen(builder: GateThreadBuilder&lt;F&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(GateCircuitBuilder::keygen(builder))
    }

    <span class="doccomment">/// Creates a mock instance of the [RangeCircuitBuilder].
    </span><span class="kw">pub fn </span>mock(builder: GateThreadBuilder&lt;F&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(GateCircuitBuilder::mock(builder))
    }

    <span class="doccomment">/// Creates an instance of the [RangeCircuitBuilder] and executes in prover mode.
    </span><span class="kw">pub fn </span>prover(
        builder: GateThreadBuilder&lt;F&gt;,
        break_points: MultiPhaseThreadBreakPoints,
    ) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(GateCircuitBuilder::prover(builder, break_points))
    }
}

<span class="kw">impl</span>&lt;F: ScalarField&gt; Circuit&lt;F&gt; <span class="kw">for </span>RangeCircuitBuilder&lt;F&gt; {
    <span class="kw">type </span>Config = RangeConfig&lt;F&gt;;
    <span class="kw">type </span>FloorPlanner = SimpleFloorPlanner;

    <span class="doccomment">/// Creates a new instance of the [RangeCircuitBuilder] without witnesses by setting the witness_gen_only flag to false
    </span><span class="kw">fn </span>without_witnesses(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self </span>{
        <span class="macro">unimplemented!</span>()
    }

    <span class="doccomment">/// Configures a new circuit using the the parameters specified [Config] and environment variable `LOOKUP_BITS`.
    </span><span class="kw">fn </span>configure(meta: <span class="kw-2">&amp;mut </span>ConstraintSystem&lt;F&gt;) -&gt; <span class="self">Self</span>::Config {
        <span class="kw">let </span>FlexGateConfigParams {
            strategy,
            num_advice_per_phase,
            num_lookup_advice_per_phase,
            num_fixed,
            k,
        } = serde_json::from_str(<span class="kw-2">&amp;</span>var(<span class="string">&quot;FLEX_GATE_CONFIG_PARAMS&quot;</span>).unwrap()).unwrap();
        <span class="kw">let </span>strategy = <span class="kw">match </span>strategy {
            GateStrategy::Vertical =&gt; RangeStrategy::Vertical,
        };
        <span class="kw">let </span>lookup_bits = var(<span class="string">&quot;LOOKUP_BITS&quot;</span>).unwrap_or_else(|<span class="kw">_</span>| <span class="string">&quot;0&quot;</span>.to_string()).parse().unwrap();
        RangeConfig::configure(
            meta,
            strategy,
            <span class="kw-2">&amp;</span>num_advice_per_phase,
            <span class="kw-2">&amp;</span>num_lookup_advice_per_phase,
            num_fixed,
            lookup_bits,
            k,
        )
    }

    <span class="doccomment">/// Performs the actual computation on the circuit (e.g., witness generation), populating the lookup table and filling in all the advice values for a particular proof.
    </span><span class="kw">fn </span>synthesize(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        config: <span class="self">Self</span>::Config,
        <span class="kw-2">mut </span>layouter: <span class="kw">impl </span>Layouter&lt;F&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
        <span class="comment">// only load lookup table if we are actually doing lookups
        </span><span class="kw">if </span>config.lookup_advice.iter().map(|a| a.len()).sum::&lt;usize&gt;() != <span class="number">0
            </span>|| !config.q_lookup.iter().all(|q| q.is_none())
        {
            config.load_lookup_table(<span class="kw-2">&amp;mut </span>layouter).expect(<span class="string">&quot;load lookup table should not fail&quot;</span>);
        }
        <span class="self">self</span>.<span class="number">0</span>.sub_synthesize(<span class="kw-2">&amp;</span>config.gate, <span class="kw-2">&amp;</span>config.lookup_advice, <span class="kw-2">&amp;</span>config.q_lookup, <span class="kw-2">&amp;mut </span>layouter);
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="doccomment">/// Configuration with [`RangeConfig`] and a single public instance column.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>RangeWithInstanceConfig&lt;F: ScalarField&gt; {
    <span class="doccomment">/// The underlying range configuration
    </span><span class="kw">pub </span>range: RangeConfig&lt;F&gt;,
    <span class="doccomment">/// The public instance column
    </span><span class="kw">pub </span>instance: Column&lt;Instance&gt;,
}

<span class="doccomment">/// This is an extension of [`RangeCircuitBuilder`] that adds support for public instances (aka public inputs+outputs)
///
/// The intended design is that a [`GateThreadBuilder`] is populated and then produces some assigned instances, which are supplied as `assigned_instances` to this struct.
/// The [`Circuit`] implementation for this struct will then expose these instances and constrain them using the Halo2 API.
</span><span class="attribute">#[derive(Clone, Debug)]
</span><span class="kw">pub struct </span>RangeWithInstanceCircuitBuilder&lt;F: ScalarField&gt; {
    <span class="doccomment">/// The underlying circuit builder
    </span><span class="kw">pub </span>circuit: RangeCircuitBuilder&lt;F&gt;,
    <span class="doccomment">/// The assigned instances to expose publicly at the end of circuit synthesis
    </span><span class="kw">pub </span>assigned_instances: Vec&lt;AssignedValue&lt;F&gt;&gt;,
}

<span class="kw">impl</span>&lt;F: ScalarField&gt; RangeWithInstanceCircuitBuilder&lt;F&gt; {
    <span class="doccomment">/// See [`RangeCircuitBuilder::keygen`]
    </span><span class="kw">pub fn </span>keygen(
        builder: GateThreadBuilder&lt;F&gt;,
        assigned_instances: Vec&lt;AssignedValue&lt;F&gt;&gt;,
    ) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ circuit: RangeCircuitBuilder::keygen(builder), assigned_instances }
    }

    <span class="doccomment">/// See [`RangeCircuitBuilder::mock`]
    </span><span class="kw">pub fn </span>mock(builder: GateThreadBuilder&lt;F&gt;, assigned_instances: Vec&lt;AssignedValue&lt;F&gt;&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ circuit: RangeCircuitBuilder::mock(builder), assigned_instances }
    }

    <span class="doccomment">/// See [`RangeCircuitBuilder::prover`]
    </span><span class="kw">pub fn </span>prover(
        builder: GateThreadBuilder&lt;F&gt;,
        assigned_instances: Vec&lt;AssignedValue&lt;F&gt;&gt;,
        break_points: MultiPhaseThreadBreakPoints,
    ) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ circuit: RangeCircuitBuilder::prover(builder, break_points), assigned_instances }
    }

    <span class="doccomment">/// Creates a new instance of the [RangeWithInstanceCircuitBuilder].
    </span><span class="kw">pub fn </span>new(circuit: RangeCircuitBuilder&lt;F&gt;, assigned_instances: Vec&lt;AssignedValue&lt;F&gt;&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ circuit, assigned_instances }
    }

    <span class="doccomment">/// Calls [`GateThreadBuilder::config`]
    </span><span class="kw">pub fn </span>config(<span class="kw-2">&amp;</span><span class="self">self</span>, k: u32, minimum_rows: <span class="prelude-ty">Option</span>&lt;usize&gt;) -&gt; FlexGateConfigParams {
        <span class="self">self</span>.circuit.<span class="number">0</span>.builder.borrow().config(k <span class="kw">as </span>usize, minimum_rows)
    }

    <span class="doccomment">/// Gets the break points of the circuit.
    </span><span class="kw">pub fn </span>break_points(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; MultiPhaseThreadBreakPoints {
        <span class="self">self</span>.circuit.<span class="number">0</span>.break_points.borrow().clone()
    }

    <span class="doccomment">/// Gets the number of instances.
    </span><span class="kw">pub fn </span>instance_count(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.assigned_instances.len()
    }

    <span class="doccomment">/// Gets the instances.
    </span><span class="kw">pub fn </span>instance(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;F&gt; {
        <span class="self">self</span>.assigned_instances.iter().map(|v| <span class="kw-2">*</span>v.value()).collect()
    }
}

<span class="kw">impl</span>&lt;F: ScalarField&gt; Circuit&lt;F&gt; <span class="kw">for </span>RangeWithInstanceCircuitBuilder&lt;F&gt; {
    <span class="kw">type </span>Config = RangeWithInstanceConfig&lt;F&gt;;
    <span class="kw">type </span>FloorPlanner = SimpleFloorPlanner;

    <span class="kw">fn </span>without_witnesses(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="self">Self </span>{
        <span class="macro">unimplemented!</span>()
    }

    <span class="kw">fn </span>configure(meta: <span class="kw-2">&amp;mut </span>ConstraintSystem&lt;F&gt;) -&gt; <span class="self">Self</span>::Config {
        <span class="kw">let </span>range = RangeCircuitBuilder::configure(meta);
        <span class="kw">let </span>instance = meta.instance_column();
        meta.enable_equality(instance);
        RangeWithInstanceConfig { range, instance }
    }

    <span class="kw">fn </span>synthesize(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        config: <span class="self">Self</span>::Config,
        <span class="kw-2">mut </span>layouter: <span class="kw">impl </span>Layouter&lt;F&gt;,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt; {
        <span class="comment">// copied from RangeCircuitBuilder::synthesize but with extra logic to expose public instances
        </span><span class="kw">let </span>range = config.range;
        <span class="kw">let </span>circuit = <span class="kw-2">&amp;</span><span class="self">self</span>.circuit.<span class="number">0</span>;
        <span class="comment">// only load lookup table if we are actually doing lookups
        </span><span class="kw">if </span>range.lookup_advice.iter().map(|a| a.len()).sum::&lt;usize&gt;() != <span class="number">0
            </span>|| !range.q_lookup.iter().all(|q| q.is_none())
        {
            range.load_lookup_table(<span class="kw-2">&amp;mut </span>layouter).expect(<span class="string">&quot;load lookup table should not fail&quot;</span>);
        }
        <span class="comment">// we later `take` the builder, so we need to save this value
        </span><span class="kw">let </span>witness_gen_only = circuit.builder.borrow().witness_gen_only();
        <span class="kw">let </span>assigned_advices = circuit.sub_synthesize(
            <span class="kw-2">&amp;</span>range.gate,
            <span class="kw-2">&amp;</span>range.lookup_advice,
            <span class="kw-2">&amp;</span>range.q_lookup,
            <span class="kw-2">&amp;mut </span>layouter,
        );

        <span class="kw">if </span>!witness_gen_only {
            <span class="comment">// expose public instances
            </span><span class="kw">let </span><span class="kw-2">mut </span>layouter = layouter.namespace(|| <span class="string">&quot;expose&quot;</span>);
            <span class="kw">for </span>(i, instance) <span class="kw">in </span><span class="self">self</span>.assigned_instances.iter().enumerate() {
                <span class="kw">let </span>cell = instance.cell.unwrap();
                <span class="kw">let </span>(cell, <span class="kw">_</span>) = assigned_advices
                    .get(<span class="kw-2">&amp;</span>(cell.context_id, cell.offset))
                    .expect(<span class="string">&quot;instance not assigned&quot;</span>);
                layouter.constrain_instance(<span class="kw-2">*</span>cell, config.instance, i);
            }
        }
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="doccomment">/// Defines stage of the circuit builder.
</span><span class="attribute">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="kw">pub enum </span>CircuitBuilderStage {
    <span class="doccomment">/// Keygen phase
    </span>Keygen,
    <span class="doccomment">/// Prover Circuit
    </span>Prover,
    <span class="doccomment">/// Mock Circuit
    </span>Mock,
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="halo2_base" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-nightly (0da281b60 2022-10-27)" ></div></body></html>
